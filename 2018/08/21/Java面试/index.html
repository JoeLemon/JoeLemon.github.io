<!DOCTYPE html><html lang="zh-cn"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Java"><title>Java面试 | JoeLemon</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java面试</h1><a id="logo" href="/.">JoeLemon</a><p class="description">一头程序员的羊皮纸</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Java面试</h1><div class="post-meta">Aug 21, 2018</div><div class="post-content"><h1 id="基础-Q-amp-A"><a href="#基础-Q-amp-A" class="headerlink" title="基础 Q&amp;A"></a>基础 Q&amp;A</h1><ol>
<li>字符串不变</li>
<li>equals()、hashCode()区别</li>
<li>Java异常类<img src="/2018/08/21/Java面试/exception.webp" title="JavaException"></li>
<li>try catch 运行<blockquote>
<ul>
<li>不管try,finally都会执行；</li>
<li>在try中return，在finally执行前会把结果保存起来，即使在finally中有修改也以try中保存的值为准，但如果是引用类型，修改的属性会以finally修改后的为准；</li>
<li>如果try/finally都有return，直接返回finally中的return。</li>
</ul>
</blockquote>
</li>
<li>Java基本类型(自动转换)<blockquote>
<p>byte[8]\short[16]\int[32]\float(32)\long(64)\double[64]\boolean[1]\char[16]</p>
</blockquote>
</li>
<li>switch支持数据类型<blockquote>
<p>byte(Byte)\short(Short)\char(Character)\int(Integer)\Enum\String(JDK 7+)<br>** 注意： break | case | default</p>
</blockquote>
</li>
<li>concat()、+区别</li>
<li>序列化</li>
<li><p>Java流</p>
<ul>
<li>IO/BIO: Blocking IO,即同步并阻塞的IO。jdk1.4之前的唯一选择，依赖于ServerSocket实现，即一个请求对应一个线程。</li>
<li>NIO: Non-Blocking IO,即同步不阻塞的IO。jdk1.4之后提供了一系列的方法来操作流，定义在java.nio包下面。相比于传统的BIO,NIO 提供了高速的面向快的I/O,它加入了Buffer、Channel、Selector等概念。它是基于事件驱动的，采用了Reactor模式，它使用一个线程管理所有的socket通道，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。它的特点是要不断主动地去询问数据有没有处理完，一般只适用于连接数目较大但连接时间短的应用，如聊天应用等。</li>
<li>AIO: NIO2.0，jdk1.7开始应用，叫做异步不阻塞的IO。AIO引入异常通道的概念，采用了Proactor模式，简化了程序编写，一个有效的请求才启动一个线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间长的应用。</li>
</ul>
<blockquote>
</blockquote>
<p>||BIO|NIO|AIO|<br>|:—|:—|:—|:—|<br>|客户端:线程数|    1:1    |M:1|    M:0|<br>|阻塞类型    |阻塞    |非阻塞    |非阻塞|<br>|同步类型|    同步|    同步|    异步|<br>|编程难度    |简单|    非常复杂|    复杂|<br>|调试难度    |简单|    复杂|    复杂|<br>|可靠性    |非常差|    高|    高|<br>|吞吐量    |低|    高|    高|</p>
</li>
</ol>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><ul>
<li>Set集合：集合元素是不能重复的，元素是没有顺序的，所以它不能基于位置访问元素。</li>
<li>List集合： 集合元素是可以重复的，元素是有顺序的，所以它可以基于位置访问元素。</li>
<li>Map：它包含键值对。Map的键是不能重复的，可以保证元素的插入顺序，也可以排序。</li>
</ul>
<p>** Set 和List 都继承了Conllection,Map没有。</p>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>HashSet是基于HashMap实现的，它不允许出现重复元素，不保证集合中元素的顺序，允许包含值为null的元素，但最多只能有一个null元素。</p>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>TreeSet可以实现排序等功能的集合，它在讲对象元素添加到集合中时会自动按照某种比较规则将其插入到有序的对象序列中，并保证该集合元素按照“升序”排列。</p>
<h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p>具有HashSet的查询速度，且内部使用链表维护元素的顺序(插入的次序),于是在使用迭代器遍历Set时，结果会按元素插入的次序显示。</p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>内部结构基于数组实现，可以对元素进行随机的访问，向ArrayList中插入与删除元素的速度慢。</p>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>LinkedList 是一个继承于AbstractSequentialList的双向链表，可以被当作堆栈、队列或双端队列进行操作。LinkedList同时还实现了List、Deque（双端队列）、Cloneable（能克隆）、java.io.Serializable（支持序列化，能通过序列化去传输）等接口，LinkedList是非同步的。</p>
<p>每个节点除含有元素外，还包含向前，向后的指针。<br><img src="/2018/08/21/Java面试/linkedList.webp" title="linkedList"></p>
<h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>Vector 是矢量队列，它是JDK1.0版本添加的类。继承于AbstractList，实现了List（支持相关的添加、删除、修改、遍历等）, RandomAccess（随机访问功能）, Cloneable（能被克隆）这些接口。</p>
<p>Vector实际上是通过一个数组去保存数据的。当我们构造Vecotr时；若使用默认构造函数，则Vector的默认容量大小是10。</p>
<p>当Vector容量不足以容纳全部元素时，Vector的容量会增加。若容量增加系数 &gt;0，则将容量的值增加“容量增加系数”；否则，将容量大小增加一倍。Vector的克隆函数，即是将全部元素克隆到一个数组中。和ArrayList不同，Vector中的操作是线程安全的。</p>
<h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><p>Stack是栈，它的特性是：先进后出(FILO, First In Last Out)。</p>
<p>Stack继承于Vector(矢量队列)的，由于Vector是通过数组实现的，这就意味着，Stack也是通过数组实现的，而非链表。</p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>HashMap底层就是一个数组结构（叫做Entry Table），数组中的每一项又是一个链表（叫做Bucket,用于解决hash冲突而设计的）。当新建一个HashMap的时候，就会初始化一个数组。插入和查询“键值对”的开销是固定的，可以通过构造器设置容量capacity和负载因子load factor，以调整容器的性能。</p>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>类似于HashMap，但是迭代遍历它时，取得“键值对”的顺序是其插入次序，或者是最近最少使用(LRU)的次序，只比HashMap慢一点。而在迭代访问时发而更快，因为它使用链表维护内部次序。</p>
<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>基于红黑树数据结构的实现，查看“键”或“键值对”时，它们会被排序(次序由Comparabel或Comparator决定)。TreeMap的特点在于，你得到的结果是经过排序的。TreeMap是唯一的带有subMap()方法的Map，它可以返回一个子树。</p>
<h3 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h3><p>Hashtable与HashMap类似，Hashtable继承自Dictionary类，实现了Map接口，不同的是它不允许记录的键或者值为空；和HashMap相比，Hashtable是线程同步的，即任一时刻只有一个线程能写Hashtable，因此也导致了 Hashtable在写入时会比较慢。而且Hashtable可以通过Enumeration去遍历。</p>
<h3 id="IdentifyHashMap"><a href="#IdentifyHashMap" class="headerlink" title="IdentifyHashMap"></a>IdentifyHashMap</h3><p>使用==代替equals()对“键”作比较的hash map。</p>
<h3 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h3><p>弱键(weak key)Map，Map中使用的对象也被允许释放，如果没有map之外的引用指向某个“键”，则此“键”可以被垃圾收集器回收。</p>
<h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p>Collections有很多自己独特的静态方法。当然它主要提供几种特殊集合(List, Map,Set)，可以调用静态方法来获得：</p>
<ul>
<li>Unmodifiable*(不可修改集合，不可添加或删除元素)</li>
<li>Synchronize*(保持同步集合，它的基本每个方法都加锁，防止并发操作)</li>
<li>Checked*(声明之始传入特定类型，以后的操作都会验证加入元素是否属于已定类型)</li>
<li>Singleton*(集合中只包含一个元素)。</li>
</ul>
<p>它们都是通过包装集合类中的抽象类获得，产生不同的行为。 </p>
<h2 id="同步集合"><a href="#同步集合" class="headerlink" title="同步集合"></a>同步集合</h2><ul>
<li><a href="http://www.importnew.com/28263.html" target="_blank" rel="noopener">ConcurrentHashMap</a></li>
<li>SynchronizedMap</li>
<li>HashTable</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除集合</span></span><br><span class="line"><span class="keyword">for</span> (Iterator&lt;String&gt; ite = list.iterator(); ite.hasNext();) &#123;</span><br><span class="line">  String str = ite.next();</span><br><span class="line">  <span class="keyword">if</span> (str.contains(<span class="string">"b"</span>)) &#123;</span><br><span class="line">    ite.remove();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><p>jdk1.5起开始提供了4个元注解，用来定义自定义注解的注解</p>
<ul>
<li><code>@Target</code>: 指定注解使用的目标范围（类、方法、字段等），其参考值见类的定义：java.lang.annotation.ElementType</li>
<li><code>@Documented</code>: 指定被标注的注解会包含在javadoc中。</li>
<li><code>@Retention</code>: 指定注解的生命周期（源码、class文件、运行时），其参考值见类的定义：java.lang.annotation.RetentionPolicy</li>
<li><code>@Inherited</code>: 指定子类可以继承父类的注解，只能是类上的注解，方法和字段的注解不能继承。即如果父类上的- <code>@Inherited修饰的就能被子类继承。</code>: jdk1.8又提供了以下两个元注解</li>
<li><code>@Native</code>[JDK1.8]: 指定字段是一个常量，其值引用native code。</li>
<li><code>@Repeatable</code>[JDK1.8]: 注解上可以使用重复注解，即可以在一个地方可以重复使用同一个注解。</li>
</ul>
<h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><ul>
<li>@Override<blockquote>
<p>确保覆盖超类中的方法</p>
</blockquote>
</li>
<li>@FunctionalInterface<blockquote>
<p>一个函数式接口只有一个抽象方法。由于默认方法有一个实现，所以它们不是抽象的。<br>与@Override注解类似，Java编译器提供了@FunctionalInterface注解以确保接口确实是函数式接口。</p>
</blockquote>
</li>
<li>@SuppressWarnings<blockquote>
<p>为了忽略某些上下文中的特定警告，JDK 5中引入了@SuppressWarnings注解。此注解接受一个或多个字符串参数——描述要忽略的警告名称:unchecked | deprecation(使用了已弃用的方法、类、类型) | removal(使用了最终废弃的方法、类、类型)</p>
</blockquote>
</li>
<li>@SafeVarargs<blockquote>
<p>当代码确保不会发生堆污染时，可使用此注解屏蔽相关警告。</p>
</blockquote>
</li>
<li>@Deprecated<blockquote>
<p>标识已弃用</p>
</blockquote>
</li>
</ul>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2018/08/22/Java多线程/">Java多线程</a><a class="next" href="/2018/08/21/Spting-MVC/">Spting MVC</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://joelemon.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/09/03/WEB安全/">WEB安全</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/03/分布式知识点/">分布式知识点</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/03/数据库基础/">数据库基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/02/CurrentHashMap/">CurrentHashMap</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/29/nginx/">nginx</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/28/Java多线程2/">Java多线程2</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/26/Java-Serlet/">Java Serlet</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/23/Java基础/">Java基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/22/Java多线程/">Java多线程</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/21/Java面试/">Java面试</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">JoeLemon.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>