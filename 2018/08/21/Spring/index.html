<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Java"><title>Spring | JoeLemon</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Spring</h1><a id="logo" href="/.">JoeLemon</a><p class="description">一头程序员的羊皮纸</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Start</i></a><a href="/archives/"><i class="fa fa-archive"> Archiv</i></a><a href="/about/"><i class="fa fa-user"> Über</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Spring</h1><div class="post-meta">Aug 21, 2018</div><div class="post-content"><h1 id="Spring作用"><a href="#Spring作用" class="headerlink" title="Spring作用"></a>Spring作用</h1><ul>
<li>轻量：Spring是轻量级的，基本的版本大小为2MB</li>
<li>控制反转：Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。</li>
<li>面向切面的编程AOP:Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。</li>
<li>容器：Spring包含并管理应用中对象的生命周期和配置</li>
<li>MVC框架： Spring-MVC</li>
<li>事务管理：Spring提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务JTA</li>
<li>异常处理：Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO抛出的）转化为一致的unchecked 异常</li>
</ul>
<h1 id="Spring模块"><a href="#Spring模块" class="headerlink" title="Spring模块"></a>Spring模块</h1><p>Spring 框架的基本模块：</p>
<ul>
<li><p><code>Spring Core</code>：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转 （IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。</p>
</li>
<li><p><code>Spring 上下文</code>：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。</p>
</li>
<li><p><code>Spring AOP</code>：通过配置管理特性，Spring AOP 模块直接将面向方面的编程功能集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理的任何对象支持 AOP。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。</p>
</li>
<li><p><code>Spring DAO</code>：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。</p>
</li>
<li><p><code>Spring ORM</code>：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。</p>
</li>
<li><p><code>Spring Web 模块</code>：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。</p>
</li>
<li><p><code>Spring MVC 框架</code>：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。</p>
</li>
</ul>
<blockquote>
<p>Core module、Bean module、Context module、Expression Language module、JDBC module、ORM module、OXM module、Java Messaging Service(JMS) module、Transaction module、Web module、Web-Servlet module、Web-Struts module、Web-Portlet module</p>
</blockquote>
<h2 id="Spring容器"><a href="#Spring容器" class="headerlink" title="Spring容器"></a>Spring容器</h2><p>Sping的容器可以分为两种类型</p>
<ol>
<li>BeanFactory：（org.springframework.beans.factory.BeanFactory接口定义）是最简单的容器，提供了基本的DI支持。最常用的BeanFactory实现就是XmlBeanFactory类，它根据XML文件中的定义加载beans，该容器从XML文件读取配置元数据并用它去创建一个完全配置的系统或应用。 </li>
<li>ApplicationContext应用上下文：（org.springframework.context.ApplicationContext）基于BeanFactory之上构建，并提供面向应用的服务。</li>
</ol>
<h2 id="核心容器（应用上下文-模块"><a href="#核心容器（应用上下文-模块" class="headerlink" title="核心容器（应用上下文) 模块"></a>核心容器（应用上下文) 模块</h2><p>这是基本的Spring模块，提供spring 框架的基础功能，BeanFactory 是 任何以spring为基础的应用的核心。Spring 框架建立在此模块之上，它使Spring成为一个容器。</p>
<h2 id="BeanFactory-–-BeanFactory-实现举例"><a href="#BeanFactory-–-BeanFactory-实现举例" class="headerlink" title="BeanFactory – BeanFactory 实现举例"></a>BeanFactory – BeanFactory 实现举例</h2><p>Bean 工厂是工厂模式的一个实现，提供了控制反转功能，用来把应用的配置和依赖从正真的应用代码中分离。最常用的BeanFactory 实现是XmlBeanFactory 类。</p>
<h2 id="XMLBeanFactory"><a href="#XMLBeanFactory" class="headerlink" title="XMLBeanFactory"></a>XMLBeanFactory</h2><p>最常用的就是org.springframework.beans.factory.xml.XmlBeanFactory ，它根据XML文件中的定义加载beans。该容器从XML 文件读取配置元数据并用它去创建一个完全配置的系统或应用。</p>
<h2 id="JDBC抽象和DAO模块"><a href="#JDBC抽象和DAO模块" class="headerlink" title="JDBC抽象和DAO模块"></a>JDBC抽象和DAO模块</h2><p>通过使用JDBC抽象和DAO模块，保证数据库代码的简洁，并能避免数据库资源错误关闭导致的问题，它在各种不同的数据库的错误信息之上，提供了一个统一的异常访问层。它还利用Spring的AOP 模块给Spring应用中的对象提供事务管理服务。</p>
<h2 id="对象-关系映射集成模块"><a href="#对象-关系映射集成模块" class="headerlink" title="对象/关系映射集成模块"></a>对象/关系映射集成模块</h2><p>Spring 通过提供ORM模块，支持我们在直接JDBC之上使用一个对象/关系映射映射(ORM)工具，Spring 支持集成主流的ORM框架，如Hiberate,JDO和 iBATIS SQL Maps。Spring的事务管理同样支持以上所有ORM框架及JDBC。</p>
<h2 id="WEB-模块"><a href="#WEB-模块" class="headerlink" title="WEB 模块"></a>WEB 模块</h2><p>Spring的WEB模块是构建在application context 模块基础之上，提供一个适合web应用的上下文。这个模块也包括支持多种面向web的任务，如透明地处理多个文件上传请求和程序级请求参数的绑定到你的业务对象。它也有对Jakarta Struts的支持。</p>
<h2 id="ApplicationContext通常的实现"><a href="#ApplicationContext通常的实现" class="headerlink" title="ApplicationContext通常的实现"></a>ApplicationContext通常的实现</h2><ul>
<li><p><code>FileSystemXmlApplicationContext</code>：此容器从一个XML文件中加载beans的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。</p>
</li>
<li><p><code>ClassPathXmlApplicationContext</code>：此容器也从一个XML文件中加载beans的定义，这里，你需要正确设置classpath因为这个容器将在classpath里找bean配置。</p>
</li>
<li><p><code>WebXmlApplicationContext</code>：此容器加载一个XML文件，此文件定义了一个WEB应用的所有bean。</p>
</li>
</ul>
<h1 id="Spring-Bean"><a href="#Spring-Bean" class="headerlink" title="Spring Bean"></a>Spring Bean</h1><p>Spring beans 是那些形成Spring应用的java对象。由Spring IOC容器初始化，装配，和管理。这些beans通过容器中配置的元数据创建。比如，以XML文件中<bean> 的形式定义。</bean></p>
<h2 id="元数据定义"><a href="#元数据定义" class="headerlink" title="元数据定义"></a>元数据定义</h2><ul>
<li>XML配置文件。</li>
<li>基于注解的配置。</li>
<li>基于java的配置。</li>
</ul>
<h2 id="作用域定义"><a href="#作用域定义" class="headerlink" title="作用域定义"></a>作用域定义</h2><p>通过bean的scope属性：</p>
<ul>
<li>singleton：bean在每个Spring ioc 容器中只有一个实例。</li>
<li>prototype：一个bean的定义可以有多个实例。</li>
<li>request：每次http请求都会创建一个bean，该作用域仅在基于web的Spring ApplicationContext情形下有效。</li>
<li>session：在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</li>
<li>global-session：在一个全局的HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</li>
</ul>
<p>缺省的Spring bean 的作用域是Singleton（非线程安全）。</p>
<h2 id="Spring框架中bean的生命周期"><a href="#Spring框架中bean的生命周期" class="headerlink" title="Spring框架中bean的生命周期"></a>Spring框架中bean的生命周期</h2><img src="/2018/08/21/Spring/beanlife1.webp" title="beanlife">
<img src="/2018/08/21/Spring/beanlife2.webp" title="beanlife">
<ul>
<li>Spring容器 从XML 文件中读取bean的定义，并实例化bean。</li>
<li>Spring根据bean的定义填充所有的属性。</li>
<li>如果bean实现了BeanNameAware 接口，Spring 传递bean 的ID 到 setBeanName方法。</li>
<li>如果Bean 实现了 BeanFactoryAware 接口， Spring传递beanfactory 给setBeanFactory 方法。</li>
<li>如果有任何与bean相关联的BeanPostProcessors，Spring会在- postProcesserBeforeInitialization()方法内调用它们。</li>
<li>如果bean实现IntializingBean了，调用它的afterPropertySet方法，如果bean声明了初始化方法，调用此初始化方法。</li>
<li>如果有BeanPostProcessors 和bean 关联，这些bean的postProcessAfterInitialization() 方法将被调用。</li>
<li>如果bean实现了 DisposableBean，它将调用destroy()方法。</li>
</ul>
<p>有两个重要的bean 生命周期方法，第一个是setup ， 它是在容器加载bean的时候被调用。第二个方法是 teardown  它是在容器卸载类的时候被调用。</p>
<p>The bean 标签有两个重要的属性（init-method和destroy-method）。用它们你可以自己定制初始化和注销方法。它们也有相应的注解（@PostConstruct和@PreDestroy）。</p>
<h2 id="Spring-内部bean"><a href="#Spring-内部bean" class="headerlink" title="Spring 内部bean"></a>Spring 内部bean</h2><p>当一个bean仅被用作另一个bean的属性时，它能被声明为一个内部bean，为了定义inner bean，在Spring 的 基于XML的 配置元数据中，可以在 <property>或 <constructor-arg> 元素内使用<bean> 元素，内部bean通常是匿名的，它们的Scope一般是prototype。</bean></constructor-arg></property></p>
<h2 id="Spring中注入一个java集合"><a href="#Spring中注入一个java集合" class="headerlink" title="Spring中注入一个java集合"></a>Spring中注入一个java集合</h2><p>Spring提供以下几种集合的配置元素：</p>
<ul>
<li><p><list>类型用于注入一列值，允许有相同的值。</list></p>
</li>
<li><p><set> 类型用于注入一组值，不允许有相同的值。</set></p>
</li>
<li><p><map> 类型用于注入一组键值对，键和值都可以为任意类型。</map></p>
</li>
<li><p><props>类型用于注入一组键值对，键和值都只能为String类型。</props></p>
</li>
</ul>
<h2 id="Spring-装配bean"><a href="#Spring-装配bean" class="headerlink" title="Spring 装配bean"></a>Spring 装配bean</h2><p>装配，或bean 装配是指在Spring 容器中把bean组装到一起，前提是容器需要知道bean的依赖关系，如何通过依赖注入来把它们装配到一起。</p>
<p>自动装配，Spring 容器能够自动装配相互合作的bean，这意味着容器不需要<constructor-arg>和<property>配置，能通过Bean工厂自动处理bean之间的协作。</property></constructor-arg></p>
<p>有五种自动装配的方式，可以用来指导Spring容器用自动装配方式来进行依赖注入：</p>
<ul>
<li>no：默认的方式是不进行自动装配，通过显式设置ref 属性来进行装配。</li>
<li>byName：通过参数名 自动装配，Spring容器在配置文件中发现bean的autowire属性被设置成byname，之后容器试图匹配、装配和该bean的属性具有相同名字的bean。</li>
<li>byType：通过参数类型自动装配，Spring容器在配置文件中发现bean的autowire属性被设置成byType，之后容器试图匹配、装配和该bean的属性具有相同类型的bean。如果有多个bean符合条件，则抛出错误。</li>
<li>constructor：这个方式类似于byType， 但是要提供给构造器参数，如果没有确定的带参数的构造器参数类型，将会抛出异常。</li>
<li>autodetect：首先尝试使用constructor来自动装配，如果无法工作，则使用byType方式。</li>
</ul>
<h3 id="自动装配注解方式"><a href="#自动装配注解方式" class="headerlink" title="自动装配注解方式"></a>自动装配注解方式</h3><h4 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h4><p><code>@Autowired</code>具有强契约特征，其所标注的属性或参数必须是可装配的。如果没有Bean可以装配到@Autowired所标注的属性或参数中，自动装配就会失败，抛出NoSuchBeanDefinitionException</p>
<p>属性不一定非要装配，null值也是可以接受的。在这种场景下可以通过设置@Autowired的required属性为false来配置自动装配是可选的</p>
<p>注意required属性可以用于@Autowired注解所使用的任意地方。但是当使用构造器装配时，只有一个构造器可以将@Autowired的required属性设置为true。其他使用@Autowired注解所标注的构造器只能将required属性设置为false。此外，当使用@Autowired标注多个构造器时，Spring就会从所有满足装配条件的构造器中选择入参最多的那个构造器。 </p>
<p>可以使用@Qualifier明确指定要装配的Bean</p>
<h4 id="限定器"><a href="#限定器" class="headerlink" title="限定器"></a>限定器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.FIELF, ElementType.PARAMETER, ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Qualifier</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@Interface</span> SpecialQualifier&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>此时，可以通过自定义的@SpecialQualifier注解来代替@Qualifier来标注，也可以和@Autowired一起使用。</p>
<h4 id="Inject"><a href="#Inject" class="headerlink" title="@Inject"></a>@Inject</h4><p>和@Autowired注解一样，@Inject可以用来自动装配属性、方法和构造器；与@Autowired不同的是，@Inject没有required属性。因此@Inject注解所标注的依赖关系必须存在，如果不存在，则会抛出异常。</p>
<h4 id="Named"><a href="#Named" class="headerlink" title="@Named"></a>@Named</h4><p>相对于@Autowired对应的Qualifier，@Inject所对应的是@Named注解。</p>
<h4 id="自动装配局限性"><a href="#自动装配局限性" class="headerlink" title="自动装配局限性"></a>自动装配局限性</h4><ul>
<li>重写：你仍需用 <constructor-arg>和 <property> 配置来定义依赖，意味着总要重写自动装配。</property></constructor-arg></li>
<li>基本数据类型：你不能自动装配简单的属性，如基本数据类型，String字符串，和类。</li>
<li>模糊特性：自动装配不如显式装配精确，如果有可能，建议使用显式装配。</li>
</ul>
<h1 id="Spring-注解"><a href="#Spring-注解" class="headerlink" title="Spring 注解"></a>Spring 注解</h1><p>基于Java的配置，允许你在少量的Java注解的帮助下，进行你的大部分Spring配置而非通过XML文件。</p>
<p>以@Configuration 注解为例，它用来标记类可以当做一个bean的定义，被Spring IOC容器使用。另一个例子是@Bean注解，它表示此方法将要返回一个对象，作为一个bean注册进Spring应用上下文。点击这里学习JAVA几大元注解。</p>
<p>相对于XML文件，注解型的配置依赖于通过字节码元数据装配组件，而非尖括号的声明。</p>
<p>开发者通过在相应的类，方法或属性上使用注解的方式，直接组件类中进行配置，而不是使用xml表述bean的装配关系。</p>
<p>注解装配在默认情况下是不开启的，为了使用注解装配，我们必须在Spring配置文件中配置 <a href="context:annotation-config/" target="_blank" rel="noopener">context:annotation-config/</a>元素。</p>
<p><code>@Autowired</code> 注解提供了更细粒度的控制，包括在何处以及如何完成自动装配。它的用法和@Required一样，修饰setter方法、构造器、属性或者具有任意名称和/或多个参数的PN方法。</p>
<p>当有多个相同类型的bean却只有一个需要自动装配时，将<code>@Qualifier</code> 注解和@Autowire 注解结合使用以消除这种混淆，指定需要装配的确切的bean。点击这里学习更多常用注解。</p>
<h1 id="Spring-数据访问"><a href="#Spring-数据访问" class="headerlink" title="Spring 数据访问"></a>Spring 数据访问</h1><h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><p>使用SpringJDBC 框架，资源管理和错误处理的代价都会被减轻。所以开发者只需写statements 和 queries从数据存取数据，JDBC也可以在Spring框架提供的模板类的帮助下更有效地被使用。</p>
<p>JdbcTemplate 类提供了很多便利的方法解决诸如把数据库数据转变成基本数据类型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据错误处理。</p>
<p>Spring对数据访问对象（DAO）的支持旨在简化它和数据访问技术如JDBC，Hibernate or JDO 结合使用。这使我们可以方便切换持久层。编码时也不用担心会捕获每种技术特有的异常。</p>
<p>在Spring中有两种方式访问Hibernate：</p>
<ul>
<li>控制反转  Hibernate Template和 Callback</li>
<li>继承 HibernateDAOSupport提供一个AOP 拦截器</li>
</ul>
<p>Spring支持以下ORM：</p>
<ul>
<li>Hibernate</li>
<li>iBatis</li>
<li>JPA (Java Persistence API)</li>
<li>TopLink</li>
<li>JDO (Java Data Objects)</li>
<li>OJB</li>
</ul>
<p>用Spring的 SessionFactory 调用 LocalSessionFactory。集成过程分三步：</p>
<ul>
<li>配置the Hibernate SessionFactory</li>
<li>继承HibernateDaoSupport实现一个DAO</li>
<li>在AOP支持的事务中装配</li>
</ul>
<p>Spring支持两种类型的事务管理：</p>
<ul>
<li>编程式事务管理：这意味你通过编程的方式管理事务，给你带来极大的灵活性，但是难维护。</li>
<li>声明式事务管理：这意味着你可以将业务代码和事务管理分离，你只需用注解和XML配置来管理事务。</li>
</ul>
<p>事物管理优点：</p>
<ul>
<li>它为不同的事务API  如 JTA，JDBC，Hibernate，JPA 和JDO，提供一个不变的编程模式。</li>
<li>它为编程式事务管理提供了一套简单的API。</li>
<li>它支持声明式事务管理。</li>
<li>它和Spring各种数据访问抽象层很好得集成。</li>
</ul>
<p>** ACID</p>
<ul>
<li><code>Atomic</code>原子性：事务是由一个或多个活动所组成的一个工作单元。原子性确保事务中的所有操作全部发生或者全部不发生。</li>
<li><code>Consistent</code>一致性：一旦事务完成，系统必须确保它所建模的业务处于一致的状态</li>
<li><code>Isolated</code>隔离线：事务允许多个用户对象头的数据进行操作，每个用户的操作不会与其他用户纠缠在一起。</li>
<li><code>Durable</code>持久性：一旦事务完成，事务的结果应该持久化，这样就能从任何的系统崩溃中恢复过来。</li>
</ul>
<h2 id="JTA"><a href="#JTA" class="headerlink" title="JTA"></a>JTA</h2><p>跨多个事务资源,就需要使用<code>JtaTransactionManager</code></p>
<p>JtaTransactionManager将事务管理的职责委托给了一个JTA的实现。JTA规定了应用程序与一个或多个数据源之间协调事务的标准API。transactionManagerName属性指明了要在JNDI上查找的JTA事务管理器。</p>
<p>JtaTransactionManager将事务管理的职责委托给javax.transaction.UserTransaction和javax.transaction.TransactionManager对象。通过UserTransaction.commit()方法来提交事务。类似地，如果事务失败，UserTransaction的rollback()方法将会被调用。</p>
<h2 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h2><p>尽管Spring提供了多种声明式事务的机制，但是所有的方式都依赖这五个参数来控制如何管理事务策略。因此，如果要在Spring中声明事务策略，就要理解这些参数。(@Transactional)</p>
<h3 id="隔离级别-isolation"><a href="#隔离级别-isolation" class="headerlink" title="隔离级别(isolation)"></a>隔离级别(isolation)</h3><ul>
<li><code>ISOLATION_DEFAULT</code>: 使用底层数据库预设的隔离层级</li>
<li><code>ISOLATION_READ_COMMITTED</code>: 允许事务读取其他并行的事务已经送出（Commit）的数据字段，可以防止Dirty read问题</li>
<li><code>ISOLATION_READ_UNCOMMITTED</code>: 允许事务读取其他并行的事务还没送出的数据，会发生Dirty、Nonrepeatable、Phantom read等问题</li>
<li><code>ISOLATION_REPEATABLE_READ</code>: 要求多次读取的数据必须相同，除非事务本身更新数据，可防止Dirty、Nonrepeatable read问题</li>
<li><code>ISOLATION_SERIALIZABLE</code>: 完整的隔离层级，可防止Dirty、Nonrepeatable、Phantom read等问题，会锁定对应的数据表格，因而有效率问题</li>
</ul>
<h3 id="传播行为-propagation"><a href="#传播行为-propagation" class="headerlink" title="传播行为(propagation)"></a>传播行为(propagation)</h3><ul>
<li>PROPAGATION_REQUIRED–支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。</li>
<li>PROPAGATION_SUPPORTS–支持当前事务，如果当前没有事务，就以非事务方式执行。</li>
<li>PROPAGATION_MANDATORY–支持当前事务，如果当前没有事务，就抛出异常。</li>
<li>PROPAGATION_REQUIRES_NEW–新建事务，如果当前存在事务，把当前事务挂起。</li>
<li>PROPAGATION_NOT_SUPPORTED–以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li>
<li>PROPAGATION_NEVER–以非事务方式执行，如果当前存在事务，则抛出异常。</li>
<li>PROPAGATION_NESTED–如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。</li>
</ul>
<h3 id="只读-read-only"><a href="#只读-read-only" class="headerlink" title="只读(read-only)"></a>只读(read-only)</h3><p>如果事务只进行读取的动作，则可以利用底层数据库在只读操作时发生的一些最佳化动作，由于这个动作利用到数据库在只读的事务操作最佳化，因而必须在事务中才有效，也就是说要搭配传播行为PROPAGATION_REQUIRED、PROPAGATION_REQUIRES_NEW、PROPAGATION_NESTED来设置。</p>
<h3 id="事务超时-timeout"><a href="#事务超时-timeout" class="headerlink" title="事务超时(timeout)"></a>事务超时(timeout)</h3><p>有的事务操作可能延续很长一段的时间，事务本身可能关联到数据表的锁定，因而长时间的事务操作会有效率上的问题，对于过长的事务操作，考虑Roll back事务并要求重新操作，而不是无限时的等待事务完成。 可以设置事务超时期间，计时是从事务开始时，所以这个设置必须搭配传播行为PROPAGATION_REQUIRED、PROPAGATION_REQUIRES_NEW、PROPAGATION_NESTED来设置。</p>
<h3 id="回滚规则-rollback-for-no-rollback-for"><a href="#回滚规则-rollback-for-no-rollback-for" class="headerlink" title="回滚规则(rollback-for, no-rollback-for)"></a>回滚规则(rollback-for, no-rollback-for)</h3><p>rollback-for指事务对于那些检查型异常应当回滚而不提交；no-rollback-for指事务对于那些异常应当继续运行而不回滚。默认情况下，Spring声明事务对所有的运行时异常都进行回滚。</p>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2018/08/21/Spting-IOC-AOP/">Spting IOC&amp;AOP</a><a class="next" href="/2018/08/07/Java-Stream/">Java Stream</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://joelemon.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Kategorien</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Letzte</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/09/03/数据库基础/">数据库基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/02/CurrentHashMap/">CurrentHashMap</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/29/nginx/">nginx</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/28/Java多线程2/">Java多线程2</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/26/Java-Serlet/">Java Serlet</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/23/Java基础/">Java基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/22/Java多线程/">Java多线程</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/21/Java面试/">Java面试</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/21/Spting-MVC/">Spting MVC</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/21/Spting-IOC-AOP/">Spting IOC&AOP</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Blogroll</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">JoeLemon.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>